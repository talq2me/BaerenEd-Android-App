<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Treasure Map Quest</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Chalkboard', 'Arial Rounded MT Bold', sans-serif;
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #d4a574;
            margin-bottom: 8px;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        #starCount {
            text-align: center;
            font-size: 24px;
            color: #ffcc00;
            margin-bottom: 20px;
        }
        .map-container {
            background: #8b6914;
            border: 2px solid #654321;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            min-height: 300px;
            position: relative;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(139, 105, 20, 0.3) 2px, rgba(139, 105, 20, 0.3) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(139, 105, 20, 0.3) 2px, rgba(139, 105, 20, 0.3) 4px);
        }
        .location {
            position: absolute;
            width: 80px;
            height: 80px;
            background: #ffd700;
            border: 3px solid #ff8c00;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .location:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
        }
        .location.visited {
            background: #4CAF50;
            border-color: #2e7d32;
        }
        .location.current {
            animation: pulse 1.5s infinite;
            border-width: 5px;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .path {
            position: absolute;
            background: #ffd700;
            height: 4px;
            z-index: 1;
        }
        .problem-display {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
            min-height: 80px;
            font-size: 1em;
        }
        .problem-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        .problem-option {
            background: white;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .problem-option:hover {
            background: #fff3cd;
            transform: translateX(5px);
        }
        .problem-option.selected {
            background: #ffc107;
            border-color: #ff8c00;
        }
        .problem-option.correct {
            background: #c8e6c9;
            border-color: #4CAF50;
        }
        .problem-option.incorrect {
            background: #ffcdd2;
            border-color: #f44336;
        }
        .button {
            font-family: inherit;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            padding: 15px 30px;
            font-size: 1.2em;
            color: white;
            background: #d4a574;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin: 10px;
        }
        .button:hover {
            background: #ff8c00;
            transform: scale(1.05);
        }
        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .button-container {
            text-align: center;
            margin: 20px 0;
        }
        .feedback {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            animation: popIn 0.5s ease;
        }
        .feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        .hidden {
            display: none;
        }
        .treasure {
            position: absolute;
            font-size: 3em;
            animation: sparkle 2s infinite;
        }
        @keyframes sparkle {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üó∫Ô∏è Treasure Map Quest üó∫Ô∏è</h1>
        <div id="starCount">‚≠ê 0 / 3</div>
        
        <div class="map-container" id="mapContainer"></div>
        
        <div class="problem-display" id="problemDisplay"></div>
        
        <div id="feedbackContainer"></div>
        
        <div class="button-container">
            <button class="button hidden" id="nextButton" onclick="nextLocation()">Continue Journey ‚Üí</button>
        </div>
    </div>

    <script>
        function readText(text, lang, rate = 0.8, onEndCallback = null) {
            if (window.Android && typeof window.Android.readText === 'function') {
                window.Android.readText(text, lang);
                setTimeout(() => {
                    if (onEndCallback) onEndCallback();
                }, 1000);
            } else if ('speechSynthesis' in window) {
                if (window.currentTTSUtterance) window.speechSynthesis.cancel();
                window.currentTTSUtterance = new SpeechSynthesisUtterance(text);
                window.currentTTSUtterance.lang = lang;
                window.currentTTSUtterance.rate = rate;
                window.currentTTSUtterance.onend = () => {
                    if (onEndCallback) onEndCallback();
                    window.currentTTSUtterance = null;
                };
                window.speechSynthesis.speak(window.currentTTSUtterance);
            } else {
                if (onEndCallback) onEndCallback();
            }
        }

        let quests = [];
        let currentQuestIndex = 0;
        let correctCount = 0;
        let incorrectCount = 0;
        let maxQuestions = 3;
        let currentQuest = null;
        let currentLocationIndex = 0;
        let selectedOption = null;

        // No default quests - must load from JSON

        function getGameConfig() {
            const urlParams = new URLSearchParams(window.location.search);
            const file = urlParams.get('file');
            console.log('Treasure Map Quest - URL params:', window.location.search);
            console.log('Treasure Map Quest - file parameter:', file);
            return file || 'treasureQuests.json';
        }

        function loadQuests() {
            const fileName = getGameConfig();
            const isAndroid = window.Android !== undefined;
            
            if (isAndroid) {
                // Use Android interface to load JSON from assets
                try {
                    const jsonString = window.Android.loadJsonFile(fileName);
                    const data = JSON.parse(jsonString);
                    if (Array.isArray(data) && data.length > 0) {
                        quests = data;
                        console.log(`Loaded ${quests.length} quests from JSON file: ${fileName}`);
                        maxQuestions = Math.min(quests.length, maxQuestions);
                        startGame();
                    } else {
                        console.error(`JSON file ${fileName} is empty or invalid. Cannot load game without quest data.`);
                        document.getElementById('mapContainer').innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Error: No quest data found. Please check the JSON file.</p>';
                    }
                } catch (error) {
                    console.error('Error loading quests from JSON:', error);
                    document.getElementById('mapContainer').innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Error loading quest data. Please check the JSON file.</p>';
                }
            } else {
                // Use fetch for web
                const jsonUrl = `../data/${fileName}`;
                fetch(jsonUrl)
                    .then(response => {
                        if (response.ok) return response.json();
                        throw new Error('File not found');
                    })
                    .then(data => {
                        if (Array.isArray(data) && data.length > 0) {
                            quests = data;
                            maxQuestions = Math.min(quests.length, maxQuestions);
                            startGame();
                        } else {
                            console.error(`JSON file ${fileName} is empty or invalid. Cannot load game without quest data.`);
                            document.getElementById('mapContainer').innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Error: No quest data found. Please check the JSON file.</p>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading quests from JSON:', error);
                        document.getElementById('mapContainer').innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Error loading quest data. Please check the JSON file.</p>';
                    });
            }
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function startGame() {
            // Shuffle quests array to ensure different quests are played each time
            quests = shuffleArray(quests);
            currentQuestIndex = 0;
            correctCount = 0;
            incorrectCount = 0;
            updateStarCount();
            loadQuest();
        }

        function loadQuest() {
            if (currentQuestIndex >= maxQuestions) {
                endGame();
                return;
            }

            currentQuest = quests[currentQuestIndex];
            currentLocationIndex = 0;
            selectedOption = null;
            
            document.getElementById('feedbackContainer').innerHTML = '';
            document.getElementById('problemDisplay').innerHTML = '';
            document.getElementById('nextButton').classList.add('hidden');

            createMap();
            showLocation(0);
        }

        function createMap() {
            const map = document.getElementById('mapContainer');
            map.innerHTML = '';
            
            const mapWidth = map.offsetWidth - 60;
            const mapHeight = map.offsetHeight - 60;
            
            currentQuest.locations.forEach((location, index) => {
                const loc = document.createElement('div');
                loc.className = 'location';
                loc.style.left = (location.x / 100 * mapWidth) + 'px';
                loc.style.top = (location.y / 100 * mapHeight) + 'px';
                loc.dataset.index = index;
                
                if (index === 0) {
                    loc.textContent = 'üö©';
                    loc.classList.add('visited');
                } else if (index === currentQuest.locations.length - 1) {
                    loc.textContent = 'üíé';
                    loc.classList.add('treasure');
                } else {
                    loc.textContent = index;
                }
                
                map.appendChild(loc);
            });
            
            // Draw paths
            for (let i = 0; i < currentQuest.locations.length - 1; i++) {
                const from = currentQuest.locations[i];
                const to = currentQuest.locations[i + 1];
                
                const path = document.createElement('div');
                path.className = 'path';
                
                const x1 = from.x / 100 * mapWidth + 40;
                const y1 = from.y / 100 * mapHeight + 40;
                const x2 = to.x / 100 * mapWidth + 40;
                const y2 = to.y / 100 * mapHeight + 40;
                
                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                path.style.width = length + 'px';
                path.style.left = x1 + 'px';
                path.style.top = y1 + 'px';
                path.style.transform = `rotate(${angle}deg)`;
                path.style.transformOrigin = '0 50%';
                
                map.appendChild(path);
            }
        }

        function showLocation(index) {
            const location = currentQuest.locations[index];
            const locElement = document.querySelector(`.location[data-index="${index}"]`);
            
            // Update location states
            document.querySelectorAll('.location').forEach((loc, i) => {
                loc.classList.remove('current');
                loc.onclick = null; // Clear previous handlers
                loc.style.cursor = 'default';
                if (i < index) loc.classList.add('visited');
            });
            
            if (locElement) {
                locElement.classList.add('current');
            }
            
            // Make next location clickable
            if (index < currentQuest.locations.length - 1) {
                const nextLoc = document.querySelector(`.location[data-index="${index + 1}"]`);
                if (nextLoc) {
                    nextLoc.onclick = () => {
                        if (index + 1 === currentLocationIndex + 1) {
                            currentLocationIndex++;
                            showLocation(currentLocationIndex);
                        }
                    };
                    nextLoc.style.cursor = 'pointer';
                }
            }
            
            if (location.problem) {
                showProblem(location.problem);
            } else if (index === currentQuest.locations.length - 1) {
                // Treasure reached!
                correctCount++;
                updateStarCount();
                document.getElementById('problemDisplay').innerHTML = 
                    '<h2 style="text-align: center; color: #ffd700;">üéâ Treasure Found! üéâ</h2>';
                document.getElementById('feedbackContainer').innerHTML = 
                    '<div class="feedback correct">You completed the quest!</div>';
                setTimeout(() => {
                    document.getElementById('nextButton').classList.remove('hidden');
                    document.getElementById('nextButton').textContent = 'Next Quest ‚Üí';
                }, 2000);
            } else {
                // Start location
                document.getElementById('problemDisplay').innerHTML = 
                    '<h3 style="text-align: center;">Your quest begins! Click on the next location on the map.</h3>';
            }
        }

        function showProblem(problem) {
            const display = document.getElementById('problemDisplay');
            display.innerHTML = `
                <h3>Solve this problem to continue:</h3>
                <p style="font-size: 1.3em; font-weight: bold; margin: 15px 0;">${problem.question}</p>
                <div class="problem-options" id="problemOptions"></div>
                <div style="text-align: center; margin-top: 15px;">
                    <button class="button" onclick="submitAnswer()">Submit Answer</button>
                </div>
            `;
            
            const optionsContainer = document.getElementById('problemOptions');
            problem.options.forEach((option, index) => {
                const opt = document.createElement('div');
                opt.className = 'problem-option';
                opt.textContent = option;
                opt.dataset.index = index;
                opt.onclick = () => selectOption(opt, index);
                optionsContainer.appendChild(opt);
            });
            
            selectedOption = null;
        }

        function selectOption(optionDiv, index) {
            document.querySelectorAll('.problem-option').forEach(opt => opt.classList.remove('selected'));
            optionDiv.classList.add('selected');
            selectedOption = index;
        }

        function submitAnswer() {
            if (selectedOption === null) {
                document.getElementById('feedbackContainer').innerHTML = 
                    '<div class="feedback" style="background: #f8d7da; color: #721c24;">Please select an answer!</div>';
                return;
            }
            
            const problem = currentQuest.locations[currentLocationIndex].problem;
            const isCorrect = selectedOption === problem.correct;
            
            const options = document.querySelectorAll('.problem-option');
            options.forEach((opt, index) => {
                opt.onclick = null;
                if (index === problem.correct) {
                    opt.classList.add('correct');
                } else if (index === selectedOption && !isCorrect) {
                    opt.classList.add('incorrect');
                }
            });
            
            if (isCorrect) {
                document.getElementById('feedbackContainer').innerHTML = 
                    '<div class="feedback correct">‚úì Correct! You can continue!</div>';
                currentLocationIndex++;
                setTimeout(() => {
                    showLocation(currentLocationIndex);
                }, 2000);
            } else {
                incorrectCount++;
                document.getElementById('feedbackContainer').innerHTML = 
                    '<div class="feedback" style="background: #f8d7da; color: #721c24;">‚úó Try again!</div>';
                setTimeout(() => {
                    showProblem(problem);
                }, 2000);
            }
        }

        function nextLocation() {
            if (currentLocationIndex < currentQuest.locations.length - 1) {
                currentLocationIndex++;
                showLocation(currentLocationIndex);
            } else {
                // Next quest
                currentQuestIndex++;
                loadQuest();
            }
        }

        function updateStarCount() {
            document.getElementById("starCount").innerText = `‚≠ê ${correctCount} / ${maxQuestions}`;
        }

        function endGame() {
            document.getElementById('mapContainer').innerHTML = 
                '<h2 style="text-align: center; padding: 50px;">üéâ All Quests Complete! üéâ</h2>';
            document.getElementById('problemDisplay').innerHTML = 
                `<p style="text-align: center; font-size: 1.5em;">Final Score: ${correctCount}/${maxQuestions}‚≠ê</p>`;
            document.querySelector('.button-container').innerHTML = '';
            
            if (window.Android && typeof window.Android.gameCompleted === 'function') {
                window.Android.gameCompleted(correctCount, incorrectCount);
            } else if (window.parent && window.parent !== window) {
                window.parent.postMessage({ type: 'gameCompleted', correct: correctCount, incorrect: incorrectCount }, '*');
            }
            setTimeout(() => {
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({ type: 'closeModal' }, '*');
                } else {
                    history.back();
                }
            }, 3000);
        }

        document.addEventListener('DOMContentLoaded', loadQuests);
    </script>
</body>
</html>

